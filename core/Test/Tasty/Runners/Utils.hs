{-# LANGUAGE BangPatterns #-}

-- | Note: this module is re-exported as a whole from "Test.Tasty.Runners"
module Test.Tasty.Runners.Utils where

import Control.Exception
import Control.Applicative
import Control.Monad
#ifndef VERSION_clock
import Data.Time.Clock.POSIX (getPOSIXTime)
#endif
import Data.Typeable (Typeable)
import Prelude  -- Silence AMP import warnings
import Text.Printf
import Foreign.C (CInt)
#ifdef VERSION_clock
import qualified System.Clock as Clock
#endif

#if INSTALL_HANDLERS
import System.Posix.Signals as Sig
import System.Mem.Weak (deRefWeak)
import Control.Concurrent (mkWeakThreadId, myThreadId)
import Data.IORef
#endif

import Test.Tasty.Core (Time)

-- | Catch possible exceptions that may arise when evaluating a string.
-- For normal (total) strings, this is a no-op.
--
-- This function should be used to display messages generated by the test
-- suite (such as test result descriptions).
--
-- See e.g. <https://github.com/UnkindPartition/tasty/issues/25>
formatMessage :: String -> IO String
formatMessage = go 3
  where
    -- to avoid infinite recursion, we introduce the recursion limit
    go :: Int -> String -> IO String
    go 0        _ = return "exceptions keep throwing other exceptions!"
    go recLimit msg = do
      mbStr <- try $ evaluate $ forceElements msg
      case mbStr of
        Right () -> return msg
        Left e' -> printf "message threw an exception: %s" <$> go (recLimit-1) (show (e' :: SomeException))

-- | Force elements of a list
-- (<https://ro-che.info/articles/2015-05-28-force-list>)
forceElements :: [a] -> ()
forceElements = foldr seq ()

{-# DEPRECATED installSignalHandlers "installSignalHandlers is a no-op now. Please use withSignalHandlers instead" #-}
-- | This was an old way to install signal handlers. The issue with it was that
-- it didn't communicate the signal information to the parent process
-- (see <https://www.cons.org/cracauer/sigint.html>). It is now deprecated in
-- favor of 'withSignalHandlers' and is a no-op, left only for backwards
-- compatibility.
installSignalHandlers :: IO ()
installSignalHandlers = return ()

-- see https://ro-che.info/articles/2014-07-30-bracket
-- | Install signal handlers while the action is running so that e.g. the cursor
-- is restored if the test suite is killed by SIGTERM. Upon a signal, a
-- 'SignalException' will be thrown to the thread that has executed this action
-- in order to let it clean up. However, once the clean up is finished, the
-- original signal will be raised again in order to communicate to the parent
-- process that we finished abnormally because of it (see
-- <https://www.cons.org/cracauer/sigint.html>).
--
-- After the action returns, the signal actions are restored to their original
-- handlers.
--
-- This function is called automatically from the @defaultMain*@ family of
-- functions. You only need to call it explicitly if you call
-- 'tryIngredients' yourself.
--
-- This function does nothing on non-UNIX systems or under GHCJS.
--
-- @since 1.4.3
withSignalHandlers :: IO () -> IO ()
withSignalHandlers =
#if INSTALL_HANDLERS
  bracket install_handlers uninstall_handlers_and_maybe_die . const
  where
    signals = [ sigINT, sigHUP, sigTERM, sigUSR1, sigUSR2, sigXCPU, sigXFSZ ]
    install_handlers :: IO (IORef (Maybe Signal), [Sig.Handler])
    install_handlers = do
      main_thread_id <- myThreadId
      weak_tid <- mkWeakThreadId main_thread_id
      signal_ref <- newIORef Nothing
      old_handlers <- forM signals $ \sig ->
        installHandler sig (Catch $ handle_signal weak_tid signal_ref sig) Nothing
      return (signal_ref, old_handlers)
    uninstall_handlers_and_maybe_die :: (IORef (Maybe Signal), [Sig.Handler]) -> IO ()
    uninstall_handlers_and_maybe_die (signal_ref, old_handlers) = do
      forM_ (zip signals old_handlers) $ \(sig, old_handler) ->
        installHandler sig old_handler Nothing
      mb_received_signal <- readIORef signal_ref
      -- If we received a signal, raise it again.
      -- Now that the handlers are uninstalled, it should kill the current
      -- process, conveying the correct information to the parent process/shell
      -- (see https://www.cons.org/cracauer/sigint.html)
      mapM_ Sig.raiseSignal mb_received_signal
    handle_signal weak_tid signal_ref sig = do
      writeIORef signal_ref (Just sig)
      m <- deRefWeak weak_tid
      case m of
        Nothing  -> return ()
        Just tid -> throwTo tid (toException $ SignalException sig)
#else
  const $ return ()
#endif
-- | This exception is thrown when the program receives a signal, assuming
-- 'installSignalHandlers' was called.
--
-- The 'CInt' field contains the signal number, as in
-- 'System.Posix.Signals.Signal'. We don't use that type synonym, however,
-- because it's not available on non-UNIXes.
newtype SignalException = SignalException CInt
  deriving (Show, Typeable)
instance Exception SignalException

-- | Measure the time taken by an 'IO' action to run
timed :: IO a -> IO (Time, a)
timed t = do
  start <- getTime
  !r    <- t
  end   <- getTime
  return (end-start, r)

#ifdef VERSION_clock
-- | Get monotonic time
--
-- Warning: This is not the system time, but a monotonically increasing time
-- that facilitates reliable measurement of time differences.
getTime :: IO Time
getTime = do
  t <- Clock.getTime Clock.Monotonic
  let ns = realToFrac $
#if MIN_VERSION_clock(0,7,1)
        Clock.toNanoSecs t
#else
        Clock.timeSpecAsNanoSecs t
#endif
  return $ ns / 10 ^ (9 :: Int)
#else
-- | Get system time
getTime :: IO Time
getTime = realToFrac <$> getPOSIXTime
#endif
